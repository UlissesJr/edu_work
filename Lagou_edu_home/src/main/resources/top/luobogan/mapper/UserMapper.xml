<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

    <!--    ${} 与 #{} 区别【笔试题】-->
    <!--    #{} :表示一个占位符号-->
    <!--    通过#{} 可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#-->
    <!--    {}可以有效防止sql注入。-->
    <!--    #{} 可以接收简单类型值或pojo属性值。-->
    <!--    如果parameterType传输单个简单类型值， #{} 括号中名称随便写。-->
    <!--    ${} :表示拼接sql串-->
    <!--    通过${} 可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，会出现sql注入-->
    <!--    问题。-->
    <!--    ${} 可以接收简单类型值或pojo属性值。-->
    <!--    如果parameterType传输单个简单类型值， ${} 括号中只能是value。-->
    <!--    补充：TextSqlNode.java 源码可以证明-->

    <!--
        Mapper.xml映射文件中的namespace与mapper接口的全限定名相同
        Mapper接口方法名和Mapper.xml映射文件中定义的每个statement的id相同
        Mapper接口方法的输入参数类型和mapper.xml映射文件中定义的每个sql的parameterType的类型相同
        Mapper接口方法的输出参数类型和mapper.xml映射文件中定义的每个sql的resultType的类型相同
    -->
<mapper namespace="top.luobogan.mapper.UserMapper">

    <!--  根据id查询用户  resultType使用全限定类名，起了别名的话可以使用别名  #{id}这里的id可以随便起名    -->
    <select id="findUserById" parameterType="int" resultType="top.luobogan.pojo.User">
        select * from user where id = #{id}
    </select>

    <!--  手动配置实体属性与表中字段的映射关系，完成手动封装  -->
    <!--  id：标签的唯一标识  type：封装后的实体类型  -->
    <resultMap id="userResultMap" type="top.luobogan.pojo.User">
        <!--  手动配置映射关系  -->
        <!--  id 用来配置主键  property 对应实体中的属性名 column对应数据表的字段名  -->
        <id property="id" column="id"></id>
        <!--  result就是对表中普通字段封装  -->
        <result property="username" column="username"></result>
        <result property="birthday" column="birthday"></result>
        <result property="sex" column="sex"></result>
        <result property="address" column="address"></result>
    </resultMap>

    <select id="findAllResultMap"  resultMap="userResultMap">
        select * from user
    </select>

    <!--  多条件查询方式一：使用 #{arg0}-#{argn} 或者 #{param1}-#{paramn} 获取参数  这里的parameterType可以不用配置 -->
    <select id="findByIdAndUsername" resultMap="userResultMap">
        select * from user where id = #{arg0} and username = #{arg1}
    </select>

    <!--  多条件查询方式二：使用 @param() 注解 -->
    <select id="findByIdAndUsername2" resultMap="userResultMap">
        select * from user where id = #{id} and username = #{username}
    </select>

    <!--  多条件查询方式三：推荐使用，传入参数为user实体 -->
    <select id="findByIdAndUsername3" resultMap="userResultMap" parameterType="user">
        select * from user where id = #{id} and username = #{username}
    </select>

    <!--  模糊查询方式一：因为传入类型为基本数据类型且个数只有一个，所以#{}里面的值可以随便写 -->
<!--    <select id="findByUsername" resultMap="userResultMap" parameterType="String">-->
            <!--  #{} 在Mybatis中代表占位符，引用参数值的时候会自动的添加''  -->
<!--        select * from user where username like #{username}-->
<!--    </select>  -->

    <!--  模糊查询方式二： -->
    <select id="findByUsername" resultMap="userResultMap" parameterType="String">
        <!--  parameterType 为基本数据类型或者String类型的时候 ${}里面的值只能写value -->
        <!--  ${} 代表SQL原样拼接 不会自动添加''   -->
        select * from user where username like '${value}'
    </select>

    <!--  添加用户获取返回主键：方式一
            useGeneratedKeys : 声明返回主键 keyProperty：表示将返回的值封装到实体类的哪个属性上
            注意：只适用于主键自增的数据库，mysql和sqlserver支持，oracle不行。
    -->
    <insert id="saveUser" parameterType="user" useGeneratedKeys="true" keyProperty="id">
        insert into user (username,birthday,sex,address) values (#{username},#{birthday},#{sex},#{address})
    </insert>

    <!--  添加用户获取返回主键：方式二
            useGeneratedKeys : 声明返回主键 keyProperty：表示将返回的值封装到实体类的哪个属性上
            注意：只适用于主键自增的数据库，mysql和sqlserver支持，oracle不行。
    -->
    <insert id="saveUser2" parameterType="user" >
        <!--
            selectKey 适用范围更广，支持所有类型数据库
            order="AFTER" 表示这条语句要在insert语句执行之后执行
            keyColumn: 指定主键对应的数据库的字段名
            keyProperty: 把返回主键的值，封装到实体中的哪个属性上
        -->
        <selectKey order="AFTER" keyColumn="id" keyProperty="id" resultType="int">
            select last_insert_id();
        </selectKey>
        insert into user (username,birthday,sex,address) values (#{username},#{birthday},#{sex},#{address})
    </insert>


</mapper>